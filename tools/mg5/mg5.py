"""
# mg5.py is a part of the HEPTAPOD package.
# Copyright (C) 2025 HEPTAPOD authors (see AUTHORS for details).
# HEPTAPOD is licensed under the GNU GPL v3 or later, see LICENSE for details.
# Please respect the MCnet Guidelines, see GUIDELINES for details.
"""
import os, json, datetime, subprocess
from typing import Optional

from orchestral.tools.base.tool import BaseTool
from orchestral.tools.base.field_utils import RuntimeField, StateField

import subprocess

SCHEMA_VERSION = "evtjsonl-1.0"

# ====================================================================== #
# ========================= Helper functions =========================== #
# ====================================================================== #

def _resolve_mg5_exec(mg5_root: str) -> str:
    """
    Given MG5 root dir (e.g. /path/to/MG5_aMC_vX.X.X)
    return absolute path to mg5_aMC executable inside bin/.

    Raise ValueError if not found or not executable.
    """
    if mg5_root is None or mg5_root.strip() == "":
        raise ValueError("mg5_path was not provided")

    mg5_root_abs = os.path.abspath(mg5_root)
    exe_path = os.path.join(mg5_root_abs, "bin", "mg5_aMC")

    if not os.path.isfile(exe_path):
        raise ValueError(f"mg5_aMC not found at {exe_path}")
    if not os.access(exe_path, os.X_OK):
        raise ValueError(f"mg5_aMC is not executable at {exe_path}")

    return exe_path

def _rel_if_inside(base_dir: str, path: str) -> str:
    """Return a relative path if the given path is inside the base directory."""
    base_dir = os.path.abspath(base_dir)
    path_abs = os.path.abspath(path)
    if path_abs.startswith(base_dir + os.sep) or path_abs == base_dir:
        return os.path.relpath(path_abs, base_dir)
    return path_abs  # fallback absolute

def _find_lhe_in_tree(root: str) -> Optional[str]:
    """Search for unweighted_events.lhe file in the directory tree."""
    for r, dnames, fnames in os.walk(root):
        for fn in fnames:
            if fn.startswith("unweighted_events.lhe"):
                return os.path.join(r, fn)
    return None

def _grep_lhe_from_log(log_path: str) -> Optional[str]:
    """Search for LHE file paths in the MadGraph log file."""
    try:
        with open(log_path, "r", encoding="utf-8") as fp:
            for line in fp:
                # Crude heuristic: look for "unweighted_events.lhe".
                if "unweighted_events.lhe" in line:
                    # Extract token ending with ".lhe" or ".lhe.gz".
                    parts = line.strip().split()
                    for tok in parts:
                        if "unweighted_events.lhe" in tok:
                            # Strip trailing punctuation.
                            cand = tok.rstrip(",'\")")
                            if os.path.exists(cand):
                                return cand
    except Exception:
        pass
    return None


def _safe_join(base_dir: str, rel_path: str) -> Optional[str]:
    """
    Resolve rel_path against base_dir.
    Return absolute path if and only if it is inside base_dir.
    Otherwise return None.
    """
    if rel_path is None:
        return None
    rel_norm = rel_path.lstrip(os.sep)
    full = os.path.abspath(os.path.join(base_dir, rel_norm))
    # Allow base_dir itself as edge case.
    if not (full == base_dir or full.startswith(base_dir + os.sep)):
        return None
    return full

def _now_utc_iso() -> str:
    return datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc).isoformat()

def _detect_scan_runs(events_dir: str) -> list:
    """
    Detect if MadGraph performed a parameter scan by looking for run_XX subdirectories.

    Returns:
        List of run directory paths (e.g., ["run_01", "run_02", "run_03"]) if scan detected.
        Empty list if no scan (single run or no runs found).
    """
    if not os.path.isdir(events_dir):
        return []

    # Look for run_XX directories
    run_dirs = []
    for entry in os.listdir(events_dir):
        entry_path = os.path.join(events_dir, entry)
        if os.path.isdir(entry_path) and entry.startswith("run_"):
            run_dirs.append(entry)

    # Sort to ensure consistent ordering (run_01, run_02, ...)
    run_dirs.sort()

    # Only consider it a scan if we have multiple runs
    return run_dirs if len(run_dirs) > 1 else []

def _parse_scan_summary(scan_file: str) -> dict:
    """
    Parse the scan_run_0[1-3].txt file generated by MadGraph parameter scans.

    Expected format:
        #run_name            mass#9000005         cross                error
        run_01               1.000000e+03         1.018011e-01         9.330523e-05
        run_02               1.500000e+03         8.741885e-03         7.437245e-06

    Returns:
        Dictionary mapping run_id to {param_name: value, cross_section: ..., error: ...}
    """
    scan_info = {}

    try:
        with open(scan_file, "r") as f:
            lines = f.readlines()

        if len(lines) < 2:
            return scan_info

        # Parse header to get parameter names
        header = lines[0].strip()
        if not header.startswith("#"):
            return scan_info

        # Extract column names from header
        # Format: #run_name  param1  param2  cross  error
        cols = header[1:].split()  # Remove leading #

        # Find indices for known columns
        param_cols = []
        cross_idx = None
        error_idx = None

        for i, col in enumerate(cols):
            if col == "run_name":
                continue
            elif col == "cross":
                cross_idx = i
            elif col == "error":
                error_idx = i
            else:
                # Assume it's a parameter column
                param_cols.append((i, col))

        # Parse data lines
        for line in lines[1:]:
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            parts = line.split()
            if len(parts) < len(cols):
                continue

            run_id = parts[0]
            run_data = {}

            # Extract parameter values
            for idx, param_name in param_cols:
                try:
                    run_data[param_name] = float(parts[idx])
                except (ValueError, IndexError):
                    pass

            # Extract cross-section and error
            if cross_idx is not None:
                try:
                    run_data["cross_section"] = float(parts[cross_idx])
                except (ValueError, IndexError):
                    pass

            if error_idx is not None:
                try:
                    run_data["cross_section_error"] = float(parts[error_idx])
                except (ValueError, IndexError):
                    pass

            scan_info[run_id] = run_data

    except Exception:
        # If parsing fails, return empty dict (non-fatal)
        pass

    return scan_info

def _find_all_lhe_files(events_dir: str, run_dirs: list) -> dict:
    """
    Find LHE files for each run in a scan.

    Args:
        events_dir: Path to the Events directory
        run_dirs: List of run directory names (e.g., ["run_01", "run_02"])

    Returns:
        Dictionary mapping run_id to LHE file path
    """
    lhe_files = {}

    for run_id in run_dirs:
        run_path = os.path.join(events_dir, run_id)
        if not os.path.isdir(run_path):
            continue

        # Look for unweighted_events.lhe or .lhe.gz in this run directory
        for fname in os.listdir(run_path):
            if fname.startswith("unweighted_events.lhe"):
                lhe_files[run_id] = os.path.join(run_path, fname)
                break

    return lhe_files

def _edit_mg5_card(card_text: str, *, ufo_path: Optional[str] = None,
                   output_name: Optional[str] = None, nevents: Optional[int] = None,
                   seed: Optional[int] = None) -> str:
    """
    Edit MG5 command card by replacing specific lines.

    Args:
        card_text: Original card content
        ufo_path: If provided, replaces the 'import model' line
        output_name: If provided, replaces the 'output' line
        nevents: If provided, replaces the 'set nevents' line
        seed: If provided, replaces the 'set iseed' line

    Returns:
        Modified card text
    """
    lines = card_text.splitlines()
    output_lines = []

    for line in lines:
        stripped = line.strip()

        # Replace 'import model' line
        if ufo_path is not None and stripped.startswith("import model"):
            output_lines.append(f"import model {ufo_path}")
            continue

        # Replace 'output' line
        if output_name is not None and stripped.startswith("output "):
            output_lines.append(f"output {output_name}")
            continue

        # Replace 'set nevents' line
        if nevents is not None and stripped.startswith("set nevents"):
            output_lines.append(f"set nevents {nevents}")
            continue

        # Replace 'set iseed' line
        if seed is not None and stripped.startswith("set iseed"):
            output_lines.append(f"set iseed {seed}")
            continue

        # Keep original line
        output_lines.append(line)

    result = "\n".join(output_lines)

    # Preserve trailing newline if original had one
    if card_text.endswith("\n"):
        result += "\n"

    return result


# ====================================================================== #
# ========================= MG5_aMC@NLO tool =========================== #
# ====================================================================== #

class MadGraphFromRunCardTool(BaseTool):
    """
    Run MadGraph5_aMC@NLO to generate parton-level events given a .mg5 run card template.

    Inputs (runtime):
      - data_dir: output directory (relative to base_directory) where this run will live
      - command_card: path (relative to base_directory) to MG5 command card template file
      - ufo_path: (optional) path to UFO model directory. If provided, replaces 'import model' line.
      - output_name: (optional) process output directory name. If provided, replaces 'output' command.
      - nevents: (optional) number of events to generate. If provided, replaces 'set nevents' command.
      - seed: (optional) random seed. If provided, replaces 'set iseed' command.

    State:
      - mg5_path: absolute path to MG5_aMC install dir (contains bin/mg5_aMC)
      - base_directory: sandbox root for all file operations

    Behavior:
      1. Read the template command card.
      2. Apply runtime substitutions (UFO path, output name, nevents, seed) if provided.
      3. Write the modified card to data_dir.
      4. Launch mg5_aMC to create process directory and generate events.
      5. Return summary with pointer to produced LHE path.
    """
    # --------------------------- Runtime fields --------------------------- #

    data_dir: str = RuntimeField(description="Relative output directory for dataset, e.g. 'data/mg_run001'")
    command_card: str = RuntimeField(description="Relative path (inside base_directory) to MG5 command card template")
    ufo_path: Optional[str] = RuntimeField(default=None, description="Path to UFO model directory (replaces 'import model' line)")
    output_name: Optional[str] = RuntimeField(default=None, description="Process output directory name (replaces 'output' command)")
    nevents: Optional[int] = RuntimeField(default=None, description="Number of events to generate (replaces 'set nevents')")
    seed: Optional[int] = RuntimeField(default=None, description="Random seed (replaces 'set iseed')")

    # --------------------------------------------------------------------- #

    # ---------------------------- State fields ---------------------------- #

    mg5_path: str = StateField(description="Absolute path to top-level MG5_aMC install dir containing bin/mg5_aMC")
    base_directory: str = StateField(description="Base sandbox root for all file ops")

    # ---------------------------------------------------------------------- #

    def _setup(self):
        """Set up the tool by validating base directory."""
        self.base_directory = os.path.abspath(self.base_directory)
        if not os.path.isdir(self.base_directory):
            raise ValueError(f"Base directory does not exist or is not a directory: {self.base_directory}")

    def _run(self) -> str:
        """Run the MadGraph event generation from the command card."""
        # Validate base directory.
        try:
            self._setup()
        except Exception as e:
            return self.format_error(error="Path Error", reason=str(e))

        outdir = _safe_join(self.base_directory, self.data_dir)
        cmd_src = _safe_join(self.base_directory, self.command_card)

        if outdir is None or cmd_src is None:
            return self.format_error(
                error="Access Denied",
                reason="data_dir or command_card escapes base_directory",
                suggestion="Use sandbox-relative paths"
            )

        if not os.path.exists(cmd_src):
            return self.format_error(
                error="File Not Found",
                reason="MG5 command card not found",
                context=self.command_card
            )

        os.makedirs(outdir, exist_ok=True)

        cmd_local_path = os.path.join(outdir, "mg5_command.txt")
        log_local_path = os.path.join(outdir, "mg5_run.log")

        # Read template card and apply runtime substitutions
        try:
            with open(cmd_src, "r", encoding="utf-8") as f:
                card_text = f.read()
        except Exception as e:
            return self.format_error(
                error="Read Error",
                reason=str(e),
                context=self.command_card
            )

        # Apply edits based on runtime fields
        try:
            # Resolve UFO path if provided (make absolute relative to base_directory)
            ufo_abs = None
            if self.ufo_path is not None:
                ufo_abs = _safe_join(self.base_directory, self.ufo_path)
                if ufo_abs is None:
                    return self.format_error(
                        error="Access Denied",
                        reason="ufo_path escapes base_directory",
                        context=self.ufo_path
                    )
                if not os.path.exists(ufo_abs):
                    return self.format_error(
                        error="Path Not Found",
                        reason="UFO directory not found",
                        context=self.ufo_path
                    )

            card_text = _edit_mg5_card(
                card_text,
                ufo_path=ufo_abs,
                output_name=self.output_name,
                nevents=self.nevents,
                seed=self.seed
            )
        except Exception as e:
            return self.format_error(
                error="Card Edit Error",
                reason=str(e),
                suggestion="Check template card format"
            )

        # Write modified card
        try:
            with open(cmd_local_path, "w", encoding="utf-8") as f:
                f.write(card_text)
        except Exception as e:
            return self.format_error(
                error="File Write Error",
                reason=str(e),
                suggestion="Check permissions"
            )
        
        # Resolve executable.
        try:
            mg5_exec = _resolve_mg5_exec(self.mg5_path)
        except Exception as e:
            return self.format_error(
                error="Dependency Missing",
                reason=str(e),
                suggestion="Pass a valid mg5_path pointing to MG5_aMC_v*/"
            )

        # Generate events.
        with open(log_local_path, "w", encoding="utf-8") as logfp:
            completed = subprocess.run(
                [mg5_exec, cmd_local_path],
                cwd=outdir,               # run inside outdir for reproducibility
                stdout=logfp,
                stderr=subprocess.STDOUT,
                text=True,
            )
        if completed.returncode != 0:
            return self.format_error(
                error="MadGraph Error",
                reason="mg5_aMC exited nonzero",
                suggestion="Inspect mg5_run.log for details",
                context=f"log={os.path.relpath(log_local_path, self.base_directory)}"
            )

        if completed.returncode != 0:
            return self.format_error(
                error="MadGraph Error",
                reason="mg5_aMC exited nonzero",
                context=completed.stderr[-1000:],  # tail for debugging
                suggestion="Inspect proc_card.dat syntax and model import"
            )

        # Try to locate LHE file and detect parameter scans.
        lhe_candidate = _find_lhe_in_tree(outdir)
        if lhe_candidate is None:
            lhe_candidate = _grep_lhe_from_log(log_local_path)

        if lhe_candidate is None:
            return self.format_error(
                error="Output Missing",
                reason="Could not locate unweighted_events.lhe",
                suggestion="Check mg5_run.log and confirm 'output' + 'launch' ran"
            )

        # Detect if this was a parameter scan by looking for the Events directory
        # The LHE file path structure helps us find it
        # Typical path: outdir/process_name/Events/run_01/unweighted_events.lhe.gz
        events_dir = None
        lhe_parent = os.path.dirname(lhe_candidate)

        # Walk up the directory tree to find "Events" directory
        for _ in range(3):  # Check up to 3 levels up
            parent_name = os.path.basename(lhe_parent)
            if parent_name == "Events":
                events_dir = lhe_parent
                break
            lhe_parent = os.path.dirname(lhe_parent)

        # Detect scan runs
        scan_detected = False
        scan_runs = []
        scan_summary_file = None

        if events_dir:
            scan_runs = _detect_scan_runs(events_dir)
            scan_detected = len(scan_runs) > 0

            if scan_detected:
                # Look for scan summary file (e.g., scan_run_0[1-3].txt)
                for fname in os.listdir(events_dir):
                    if fname.startswith("scan_run_") and fname.endswith(".txt"):
                        scan_summary_file = os.path.join(events_dir, fname)
                        break

        # Build manifest.
        manifest = {
            "schema": SCHEMA_VERSION,
            "created_utc": _now_utc_iso(),
            "inputs": {
                "command_card": "mg5_command.txt",
                "mg5_root": os.path.abspath(self.mg5_path),
            },
            "outputs": {
                "lhe_path": _rel_if_inside(self.base_directory, lhe_candidate),
                "log_path": os.path.relpath(log_local_path, self.base_directory),
            },
            "tool": "MadGraphFromCardTool",
            "scan_detected": scan_detected,
        }

        if scan_detected:
            manifest["outputs"]["scan_runs"] = scan_runs
            if scan_summary_file:
                manifest["outputs"]["scan_summary_file"] = _rel_if_inside(self.base_directory, scan_summary_file)

        manifest_path = os.path.join(outdir, "manifest.json")
        with open(manifest_path, "w", encoding="utf-8") as mf:
            json.dump(manifest, mf, indent=2)

        # Build result
        result = {
            "status": "ok",
            "scan_detected": scan_detected,
            "data_dir": os.path.relpath(outdir, self.base_directory),
            "lhe_file": _rel_if_inside(self.base_directory, lhe_candidate),  # First run for backward compat
            "manifest_json": os.path.relpath(manifest_path, self.base_directory),
            "log_file": os.path.relpath(log_local_path, self.base_directory),
        }

        # If scan detected, add detailed scan information
        if scan_detected and events_dir:
            # Find all LHE files for each run
            lhe_files = _find_all_lhe_files(events_dir, scan_runs)

            # Parse scan summary if available
            scan_info = {}
            if scan_summary_file and os.path.exists(scan_summary_file):
                scan_info = _parse_scan_summary(scan_summary_file)
                result["scan_summary_file"] = _rel_if_inside(self.base_directory, scan_summary_file)

            # Build runs array
            runs = []
            for run_id in scan_runs:
                run_data = {
                    "run_id": run_id,
                    "lhe_file": _rel_if_inside(self.base_directory, lhe_files.get(run_id, ""))
                }

                # Add scan parameters and cross-section if available
                if run_id in scan_info:
                    info = scan_info[run_id]

                    # Separate scan parameters from cross-section info
                    scan_params = {}
                    for key, value in info.items():
                        if key not in ["cross_section", "cross_section_error"]:
                            scan_params[key] = value

                    if scan_params:
                        run_data["scan_params"] = scan_params

                    if "cross_section" in info:
                        run_data["cross_section"] = info["cross_section"]
                    if "cross_section_error" in info:
                        run_data["cross_section_error"] = info["cross_section_error"]

                runs.append(run_data)

            result["n_runs"] = len(runs)
            result["runs"] = runs

        return json.dumps(result, separators=(",", ":"), ensure_ascii=False)